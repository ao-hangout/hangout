"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[790],{623:function(n,e,t){var a=t(5893),s=t(3935),r=t(3438),o=t(280),i=t(7294);function d(n){let{content:e,type:t}=n,[s,d]=(0,i.useState)(!0);return(0,a.jsx)(r.Z,{open:s,autoHideDuration:5e3,anchorOrigin:{vertical:"top",horizontal:"center"},onClose:()=>d(!1),children:(0,a.jsx)(o.Z,{severity:t,children:"timeout of 60000ms exceeded"===e?"Network connection is unstable.":e})})}e.Z={dom:null,error(n){this.dom=document.createElement("div");let e=(0,a.jsx)(d,{content:n,type:"error"});s.render(e,this.dom),document.body.appendChild(this.dom)}}},6937:function(n,e,t){let a,s,r;t.d(e,{N2:function(){return w}});var o=t(7294),i=t(7386),d=t.n(i),l=t(4467),c=t(9095);async function g(n){performance.now();try{let e=await u({query:'{\n        transactions (\n          ids: "'.concat(n,'"\n        ) {\n          edges {\n            node {\n              id\n              owner {\n                address\n              }\n              tags {\n                name\n                value\n              }\n            }\n          }\n        }\n      }')});if(performance.now(),0==e.length)return"";return e[0].node.id}catch(n){return console.log("isProcessOnChain -> ERR:",n),""}}async function u(n){let e=await fetch("https://arweave.net/graphql",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)});return(await e.json()).data.transactions.edges}let{createData:m,ArweaveSigner:f}=l.default?l.default:l;function p(n){return new Promise(e=>setTimeout(e,n))}function h(){return!!a&&!!s}function _(n){return async e=>{let{data:t,tags:a,target:s,anchor:r}=e,o=new f(n),i=m(t,o,{tags:a,target:s,anchor:r});return i.sign(o).then(async()=>({id:await i.id,raw:await i.getRaw()}))}}async function T(n,e){try{return await (0,c.yw)({process:n,signer:_(s),tags:[{name:"Action",value:"Eval"}],data:e,anchor:""})}catch(n){return console.log("evaluate --> error:",n),""}}async function A(n,e,t){try{let a=await (0,c.yw)({process:n,signer:_(s),tags:[{name:"Action",value:t}],data:JSON.stringify(e)});return console.log("执行messageToAO"),a}catch(n){return console.log("messageToAO -> error:",n),""}}async function y(n,e,t){var a;let s;try{s=await (0,c.Vz)({process:n,data:JSON.stringify(t),tags:[{name:"Action",value:e}]})}catch(n){return console.log("getDataFromAO --> ERR:",n),""}let r=(null===(a=s.Messages)||void 0===a?void 0:a.length)>0?s.Messages[0].Data:null;return r?JSON.parse(r):(console.error("No messages received"),null)}function w(){let[n,e]=(0,o.useState)(!1),[t,i]=(0,o.useState)(!1),[l,u]=(0,o.useState)(!1),[m,f]=(0,o.useState)(!1),[w,I]=(0,o.useState)(!1),[S,R]=(0,o.useState)(!1);async function P(n,e,t,a,s,o){if(!h())return;f(!0),I(!1);let i=await v();console.log("spawn process --> ",i);let d=!0,l=0;for(;d;){await p(2e3);let n=await g(i);if(console.log("process isOnChain --> ",!!n),n)d=!1;else if(console.log("Try again..."),++l>=100){console.log("Process not found, please try again");return}}for(console.log("upload code to --> ",i),d=!0;d;){await p(2e3);let n=await T(i,"\n\nlocal json = require('json')\nao.addAssignable(\"info\", { Action = 'Info' })\nao.addAssignable(\"add-collection\", { Action = 'Add-Collection' })\nao.addAssignable(\"add-uploaded-asset\", { Action = 'Add-Uploaded-Asset' })\n-- Profile: {\n--   UserName\n--   DisplayName\n--   Description\n--   ProfileImage\n--   CoverImage\n--   Instruction\n--   DateCreated\n--   DateUpdated\n--   Version\n-- }\nCurrentProfileVersion = '0.0.2'\n\nif not Profile then Profile = {} end\n\nif not Profile.Version then Profile.Version = CurrentProfileVersion end\n\nif not FirstRunCompleted then FirstRunCompleted = false end\n\n-- Assets: { Id, Type, Quantity } []\n\nif not Assets then Assets = {} end\n\n-- Collections: { Id, SortOrder } []\n\nif not Collections then Collections = {} end\n\n-- keep this list consistent with registry\nlocal HandlerRoles = {\n	['Update-Profile'] = {'Owner', 'Admin'},\n	['Add-Uploaded-Asset'] = {'Owner', 'Admin', 'Contributor'},\n	['Add-Collection'] = {'Owner', 'Admin', 'Contributor'},\n	['Update-Collection-Sort'] = {'Owner', 'Admin'},\n	['Transfer'] = {'Owner', 'Admin'},\n	['Debit-Notice'] = {'Owner', 'Admin'},\n	['Credit-Notice'] = {'Owner', 'Admin'},\n	['Action-Response'] = {'Owner', 'Admin'},\n	['Run-Action'] = {'Owner', 'Admin'},\n	['Proxy-Action'] = {'Owner', 'Admin'},\n	['Update-Role'] = {'Owner', 'Admin'}\n}\n\n-- Roles: { Id, Role } []\nif not Roles then Roles = {} end\n\n-- Testing Registry\n-- REGISTRY = '_nKkAiKqJy-7pfvDTO7ts0YOO6ANg50svSuF_fx3ONc'\n\n-- Production Registry\nREGISTRY = 'SNy4m-DrqxWl01YqGM4sxI8qCni-58re8uuJLvZPypY'\n\n\nlocal function check_valid_address(address)\n	if not address or type(address) ~= 'string' then\n		return false\n	end\n	return string.match(address, \"^[%w%-_]+$\") ~= nil and #address == 43\nend\n\n-- Guard against reply attack from random assignments that are authorized\nlocal function assigned_profile_target_validated(msg)\n	-- Creator tag is set to the profile process id\n	if msg.Tags.Creator == ao.id then\n		return true\n	end\n	return false\nend\n\nlocal function check_valid_role(role, op)\n	if op == 'Delete' then\n		return true\n	end\n	if not role or type(role) ~= 'string' then\n		return false\n	end\n	return role == 'Admin' or role == 'Contributor' or role == 'Moderator' or role == 'Owner'\nend\n\nlocal function check_required_data(data, tags, required_fields)\n	local localtags = tags or {}\n	for _, field in ipairs(required_fields) do\n		if field == \"UserName\" then\n			if (data ~= nil and data[field] == '') or localtags[field] == '' then\n				return false\n			end\n		end\n		if (data ~= nil and data[field] ~= nil) or localtags[field] ~= nil  then\n			return true\n		end\n	end\n	return false\nend\n\nlocal function decode_message_data(data)\n	local status, decoded_data = pcall(json.decode, data)\n\n	if not status or type(decoded_data) ~= 'table' then\n		return false, nil\n	end\n\n	return true, decoded_data\nend\n\nlocal function authorizeRoles(msg)\n	-- TEST\n	print('PROFILE: authorizeRoles --> msg.From: ' .. msg.From)\n	print('PROFILE: authorizeRoles --> ao.id: ' .. ao.id)\n\n	-- If Roles is blank, the initial call should be from the owner\n	if msg.From ~= Owner and msg.From ~= ao.id and #Roles == 0 then\n		return false, {\n			Target = msg.Target or msg.From,\n			Action = 'Authorization-Error',\n			Tags = {\n				Status = 'Error',\n				ErrorMessage = 'Initial Roles not set, owner is not authorized for this handler'\n			}\n		}\n	end\n	-- change to 'admin', 'contributor', 'moderator', 'owner'\n	local existingRole\n\n	for _, role in pairs(Roles) do\n		if role.Id == msg.From then\n			existingRole = role.Role\n			break\n		end\n	end\n\n	-- determine if they have a role\n	-- determine if they can call the action handler\n	-- determine if owner-only actions are allowed\n\n	if not existingRole then\n		if msg.From == Owner then\n			-- If Roles table is empty or owner doesn't exist, authorize the owner\n			table.insert(Roles, {Role = \"Owner\", Id = msg.From})\n			existingRole = 'Owner'\n		else\n			return false, {\n				Target = msg.Target or msg.From,\n				Action = 'Authorization-Error',\n				Tags = {\n					Status = 'Error',\n					ErrorMessage = 'Unauthorized to access this handler'\n				}\n			}\n		end\n	else\n		-- now check if the role is allowed to access the handler\n		local handlerRoles = HandlerRoles[msg.Action]\n		if not handlerRoles then\n			return false, {\n				Target = msg.Target or msg.From,\n				Action = 'Authorization-Error',\n				Tags = {\n					Status = 'Error',\n					ErrorMessage = 'Handler does not exist'\n				}\n			}\n		else\n			local authorized = false\n			for _, role in pairs(handlerRoles) do\n				if role == existingRole then\n					authorized = true\n					break\n				end\n			end\n\n			if not authorized then\n				return false, {\n					Target = msg.Target or msg.From,\n					Action = 'Authorization-Error',\n					Tags = {\n						Status = 'Error',\n						ErrorMessage = 'Unauthorized to access this handler'\n					}\n				}\n\n			end\n			return authorized, nil\n		end\n	end\n\n	return true\nend\n\nlocal function sort_collections()\n	table.sort(Collections, function(a, b)\n		return a.SortOrder < b.SortOrder\n	end)\nend\n\nlocal function update_profile(msg)\n	local authorizeResult, message = authorizeRoles(msg)\n	if not authorizeResult then\n		ao.send(message)\n		return\n	end\n\n	local decode_check, data = decode_message_data(msg.Data)\n	local create_required_data = { \"UserName\" }\n	local update_required_data = { \"UserName\", \"DisplayName\", \"Description\", \"CoverImage\", \"ProfileImage\" }\n\n	if decode_check and data then\n		if not check_required_data(data, msg.Tags, FirstRunCompleted and update_required_data or create_required_data) then\n			ao.send({\n				Target = msg.From,\n				Action = 'Input-Error',\n				Tags = {\n					Status = 'Error',\n					EMessage =\n					'Invalid data or Tags, required at least Username for creation, or one of { UserName, DisplayName, Description, CoverImage, ProfileImage } for updates'\n				}\n			})\n			return\n		end\n\n		local function getUpdatedProfileField(tagField, dataField, profileField)\n			if tagField == \"\" then\n				return nil\n			end\n			if dataField == \"\" then\n				return nil\n			end\n			return tagField or dataField or profileField\n		end\n\n		Profile.UserName = getUpdatedProfileField(msg.Tags.UserName, data.UserName, Profile.UserName)\n		Profile.DisplayName = getUpdatedProfileField(msg.Tags.DisplayName, data.DisplayName, Profile.DisplayName)\n		Profile.Description = getUpdatedProfileField(msg.Tags.Description, data.Description, Profile.Description)\n		Profile.ProfileImage = getUpdatedProfileField(msg.Tags.ProfileImage, data.ProfileImage, Profile.ProfileImage)\n		Profile.CoverImage = getUpdatedProfileField(msg.Tags.CoverImage, data.CoverImage, Profile.CoverImage)\n		Profile.Instruction = getUpdatedProfileField(msg.Tags.Instruction, data.Instruction, Profile.Instruction)\n		Profile.DateCreated = Profile.DateCreated or msg.Timestamp\n		Profile.DateUpdated = msg.Timestamp\n\n		ao.send({\n			Target = REGISTRY,\n			Action = 'Create-Profile',\n			Data = json.encode({\n					AuthorizedAddress = msg.From,\n					UserName = Profile.UserName or nil,\n					DisplayName = Profile.DisplayName or nil,\n					Description = Profile.Description or nil,\n					ProfileImage = Profile.ProfileImage or nil,\n					CoverImage = Profile.CoverImage or nil,\n					Instruction = Profile.Instruction or nil,\n					DateCreated = Profile.DateCreated,\n					DateUpdated = Profile.DateUpdated\n			}),\n			Tags = msg.Tags\n	})\n	FirstRunCompleted = true\n\n		-- if FirstRunCompleted then\n		-- 	ao.assign({Processes = { REGISTRY }, Message = msg.Id})\n		-- else\n		-- 	ao.assign({Processes = { REGISTRY }, Message = ao.id})\n		-- 	FirstRunCompleted = true\n		-- end\n\n		if Profile.Version ~= CurrentProfileVersion then\n			Profile.Version = CurrentProfileVersion\n		end\n\n		ao.send({\n			Target = msg.From,\n			Action = 'Profile-Success',\n			Tags = {\n				Status = 'Success',\n				Message = 'Profile updated'\n			}\n		})\n	else\n		ao.send({\n			Target = msg.From,\n			Action = 'Input-Error',\n			Tags = {\n				Status = 'Error',\n				EMessage = string.format(\n						'Failed to parse data, received: %s. %s.', msg.Data,\n						'Data must be an object - { UserName, DisplayName, Description, CoverImage, ProfileImage }')\n			}\n		})\n	end\nend\n\n-- Data - { Id, Quantity } or -- Tag - { Quantity = # } - Assignment from Spawn, msg.Id is the asset ID.\n-- Backwards compatibility should be sunset in future as it does not perform validation and allows sends. Only allow via assign.\nlocal function add_uploaded_asset(msg)\n	local reply_to = msg.Target or msg.From\n	local backwards_compatibility_check = msg.Target == ao.id and true or false\n	local asset_id = msg.Id\n	local quantityNumber = tonumber(msg.Tags.Quantity)\n	local quantity = msg.Tags.Quantity or \"0\"\n\n	local decode_check, data = decode_message_data(msg.Data)\n	if backwards_compatibility_check then\n		if decode_check and data then\n			if not data.Id or not data.Quantity then\n				ao.send({\n					Target = reply_to,\n					Action = 'Input-Error',\n					Tags = {\n						Status = 'Error',\n						Message =\n						'Invalid arguments, required { Id, Quantity }'\n					}\n				})\n				return\n			end\n			asset_id = data.Id\n			quantity = data.Quantity\n			quantityNumber = tonumber(quantity)\n\n		else\n			ao.send({\n				Target = reply_to,\n				Action = 'Input-Error',\n				Tags = {\n					Status = 'Error',\n					Message = string.format(\n							'Failed to parse data, received: %s. %s.', msg.Data,\n							'Data must be an object - { Id, Quantity }')\n				}\n			})\n			return\n		end\n	else\n		if not assigned_profile_target_validated(msg) then\n			ao.send({\n				Target = reply_to,\n				Action = 'Validation-Error',\n				Tags = {\n					Status = 'Error',\n					Message =\n					'Only assignments with Creator tag from a asset spawn supported.'\n				}\n			})\n			return\n		end\n		local authorizeResult, message = authorizeRoles(msg)\n		if not authorizeResult then\n			ao.send(message)\n			return\n		end\n	end\n\n	if not check_valid_address(asset_id) then\n		ao.send({ Target = reply_to, Action = 'Validation-Error', Tags = { Status = 'Error', Message = 'Asset Id must be a valid address' } })\n		return\n	end\n\n	if not quantityNumber or quantityNumber <= 0 then\n		ao.send({\n			Target = reply_to,\n			Action = 'Input-Error',\n			Tags = {\n				Status = 'Error',\n				Message =\n				'Invalid argument, required Quantity tag on Atomic Asset Process Spawn must exist and be a number greater than 0 }'\n			}\n		})\n		return\n	end\n\n	local exists = false\n	for _, asset in ipairs(Assets) do\n		if asset.Id == asset_id then\n			exists = true\n			break\n		end\n	end\n\n	if not exists then\n		table.insert(Assets, { Id = asset_id, Type = 'Upload', Quantity = quantity })\n		ao.send({\n			Target = reply_to,\n			Action = 'Add-Uploaded-Asset-Success',\n			Tags = {\n				Status = 'Success',\n				Message = 'Asset added to profile'\n			}\n		})\n	else\n		ao.send({\n			Target = reply_to,\n			Action = 'Validation-Error',\n			Tags = {\n				Status = 'Error',\n				Message = string.format(\n						'Asset with Id %s already exists', asset_id)\n			}\n		})\n	end\nend\n\n-- Data - { Id } or msg.Id from assigned spawn message.\n-- Backwards compatibility should be sunset in future as it does not perform validation and allows sends. Only allow via assign.\nlocal function add_collection(msg)\n	local reply_to = msg.Target or msg.From\n	local backwards_compatibility_check = msg.Target == ao.id and true or false\n	local collection_id = msg.Id\n	local decode_check, data = decode_message_data(msg.Data)\n	if backwards_compatibility_check then\n		if decode_check and data then\n			if not data.Id or not data.Name then\n				ao.send({\n					Target = reply_to,\n					Action = 'Input-Error',\n					Tags = {\n						Status = 'Error',\n						Message =\n						'Invalid arguments, required { Id, Name }'\n					}\n				})\n				return\n			end\n			collection_id = data.Id\n		else\n			ao.send({\n				Target = reply_to,\n				Action = 'Input-Error',\n				Tags = {\n					Status = 'Error',\n					Message = string.format(\n							'Failed to parse data, received: %s. %s.', msg.Data,\n							'Data must be an object - { Id, Name, Items }')\n				}\n			})\n			return\n		end\n	else\n		if not assigned_profile_target_validated(msg) then\n			ao.send({\n				Target = reply_to,\n				Action = 'Validation-Error',\n				Tags = {\n					Status = 'Error',\n					Message =\n					'Only assignments with Creator tag from a collection spawn supported.'\n				}\n			})\n			return\n		end\n		local authorizeResult, message = authorizeRoles(msg)\n		if not authorizeResult then\n			ao.send(message)\n			return\n		end\n	end\n\n	if not check_valid_address(collection_id) then\n		ao.send({ Target = reply_to, Action = 'Validation-Error', Tags = { Status = 'Error', Message = 'Collection Id must be a valid address' } })\n		return\n	end\n\n	local exists = false\n	for _, collection in ipairs(Collections) do\n		if collection.Id == collection_id then\n			exists = true\n			break\n		end\n	end\n\n	-- Ensure the highest SortOrder for new items\n	local highestSortOrder = 0\n	for _, collection in ipairs(Collections) do\n		if collection.SortOrder > highestSortOrder then\n			highestSortOrder = collection.SortOrder\n		end\n	end\n\n	if not exists then\n		table.insert(Collections, { Id = collection_id, SortOrder = highestSortOrder + 1 })\n		sort_collections()\n		ao.send({\n			Target = reply_to,\n			Action = 'Add-Collection-Success',\n			Tags = {\n				Status = 'Success',\n				Message = 'Collection added'\n			}\n		})\n	else\n		ao.send({\n			Target = reply_to,\n			Action = 'Validation-Error',\n			Tags = {\n				Status = 'Error',\n				Message = string.format(\n						'Collection with Id %s already exists', collection_id)\n			}\n		})\n	end\nend\n\nHandlers.add('Info', Handlers.utils.hasMatchingTag('Action', 'Info'),\n	function(msg)\n		ao.send({\n			Target = msg.From,\n			Action = 'Read-Success',\n			Data = json.encode({\n				Profile = Profile,\n				Assets = Assets,\n				Collections = Collections,\n				Owner = Owner,\n				Roles = Roles or {}\n			})\n		})\n	end)\n\n-- Data - { UserName?, DisplayName?, Description?, CoverImage, ProfileImage }\n--[[\nThis function handles the 'Update-Profile' action. It first checks if the sender of the message is authorized to perform this action.\nIf the sender is authorized, it then decodes the data from the message. If the data is valid and contains at least one of the required fields,\nit updates the profile with the new data and sends a success message to the sender and the registry. If the data is not valid or does not contain\nany of the required fields, it sends an error message to the sender.\n\nParameters:\nmsg:\n{\n    data: { },\n    tags: { }\n\nReturns:\nNone. This function sends messages to the sender or the registry but does not return anything.\n--]]\nHandlers.add('Update-Profile', Handlers.utils.hasMatchingTag('Action', 'Update-Profile'), update_profile )\n\n-- Data - { Id, Op, Role? }\nHandlers.add('Update-Role', Handlers.utils.hasMatchingTag('Action', 'Update-Role'),\n		function(msg)\n			local authorizeResult, message = authorizeRoles(msg)\n			if not authorizeResult then\n				ao.send(message)\n				return\n			end\n\n			local decode_check, data = decode_message_data(msg.Data)\n\n			if decode_check and data then\n				local Id = data.Id or msg.Tags.Id\n				local Role = data.Role or msg.Tags.Role\n				local Op = data.Op or msg.Tags.Op\n				if not Id or not Op then\n					ao.send({\n						Target = msg.From,\n						Action = 'Input-Error',\n						Tags = {\n							Status = 'Error',\n							Message =\n							'Invalid arguments, required { Id, Op } in data or tags'\n						}\n					})\n					return\n				end\n\n				if not check_valid_address(Id) then\n					ao.send({ Target = msg.From, Action = 'Validation-Error', Tags = { Status = 'Error', Message = 'Id must be a valid address' }, Data = msg.Data })\n					return\n				end\n\n				if not check_valid_role(Role, Op) then\n					ao.send({ Target = msg.From, Action = 'Validation-Error', Tags = { Status = 'Error', Message = 'Role must be one of \"Admin\", \"Contributor\", \"Moderator\", \"Owner\"' }, Data = msg.Data })\n					return\n				end\n\n				-- Add, update, or remove role\n				local role_index = -1\n				local current_role\n				for i, role in ipairs(Roles) do\n					if role.Id == Id then\n						role_index = i\n						current_role = role.Role\n						break\n					end\n				end\n\n				if role_index == -1 then\n					if (Op == 'Add') then\n						table.insert(Roles, { Id = Id, Role = Role })\n					else\n						ao.send({\n							Target = msg.From,\n							Action = 'Update-Role-Failed',\n							Tags = {\n								Status = 'Error',\n								Message = 'Role Op not possible, role does not exist to delete or update'\n							}\n						})\n						return\n					end\n				else\n					if Op == 'Delete' and current_role ~= 'Owner' then\n						table.remove(Roles, role_index)\n					elseif Op == \"Update\" then\n						Roles[role_index].Role = Role\n					end\n				end\n\n				-- assign to registry\n				ao.assign({Processes = { REGISTRY }, Message = ao.id})\n				ao.send({\n					Target = msg.From,\n					Action = 'Update-Role-Success',\n					Tags = {\n						Status = 'Success',\n						Message = 'Role updated'\n					}\n				})\n			else\n				ao.send({\n					Target = msg.From,\n					Action = 'Input-Error',\n					Tags = {\n						Status = 'Error',\n						Message = string.format(\n								'Failed to parse data, received: %s. %s.', msg.Data,\n								'Data must be an object - { Id, Op, Role }')\n					}\n				})\n			end\n\n		end)\n\n-- Data - { Target, Recipient, Quantity }\nHandlers.add('Transfer', Handlers.utils.hasMatchingTag('Action', 'Transfer'),\n	function(msg)\n		local authorizeResult, message = authorizeRoles(msg)\n		if not authorizeResult then\n			ao.send(message)\n			return\n		end\n\n		ao.send({\n			Target = msg.Tags.Target,\n			Action = 'Transfer',\n			Tags = msg.Tags,\n			Data = msg.Data\n		})\n	end)\n\n-- Tags - { Recipient, Quantity }\nHandlers.add('Debit-Notice', Handlers.utils.hasMatchingTag('Action', 'Debit-Notice'),\n	function(msg)\n		if not msg.Tags.Recipient or not msg.Tags.Quantity then\n			ao.send({\n				Target = msg.From,\n				Action = 'Input-Error',\n				Tags = {\n					Status = 'Error',\n					Message =\n					'Invalid arguments, required { Recipient, Quantity }'\n				}\n			})\n			return\n		end\n\n		if not check_valid_address(msg.Tags.Recipient) then\n			ao.send({ Target = msg.From, Action = 'Validation-Error', Tags = { Status = 'Error', Message = 'Recipient must be a valid address' } })\n			return\n		end\n\n		local asset_index = -1\n		for i, asset in ipairs(Assets) do\n			if asset.Id == msg.From then\n				asset_index = i\n				break\n			end\n		end\n\n		if asset_index > -1 then\n			local updated_quantity = tonumber(Assets[asset_index].Quantity) - tonumber(msg.Tags.Quantity)\n\n			if updated_quantity <= 0 then\n				table.remove(Assets, asset_index)\n			else\n				Assets[asset_index].Quantity = tostring(updated_quantity)\n			end\n\n			ao.send({\n				Target = Owner,\n				Action = 'Transfer-Success',\n				Tags = {\n					Status = 'Success',\n					Message = 'Balance transferred'\n				}\n			})\n		else\n			ao.send({\n				Target = msg.From,\n				Action = 'Transfer-Failed',\n				Tags = {\n					Status = 'Error',\n					Message = 'No asset found to debit'\n				}\n			})\n		end\n	end)\n\n-- Tags - { Sender, Quantity }\nHandlers.add('Credit-Notice', Handlers.utils.hasMatchingTag('Action', 'Credit-Notice'),\n	function(msg)\n		if not msg.Tags.Sender or not msg.Tags.Quantity then\n			ao.send({\n				Target = msg.From,\n				Action = 'Input-Error',\n				Tags = {\n					Status = 'Error',\n					Message =\n					'Invalid arguments, required { Sender, Quantity }'\n				}\n			})\n			return\n		end\n\n		if not check_valid_address(msg.Tags.Sender) then\n			ao.send({ Target = msg.From, Action = 'Validation-Error', Tags = { Status = 'Error', Message = 'Sender must be a valid address' } })\n			return\n		end\n\n		local asset_index = -1\n		for i, asset in ipairs(Assets) do\n			if asset.Id == msg.From then\n				asset_index = i\n				break\n			end\n		end\n\n		if asset_index > -1 then\n			local updated_quantity = tonumber(Assets[asset_index].Quantity) + tonumber(msg.Tags.Quantity)\n\n			Assets[asset_index].Quantity = tostring(updated_quantity)\n		else\n			table.insert(Assets, { Id = msg.From, Quantity = msg.Tags.Quantity })\n\n			ao.send({\n				Target = Owner,\n				Action = 'Transfer-Success',\n				Tags = {\n					Status = 'Success',\n					Message = 'Balance transferred'\n				}\n			})\n		end\n		-- send wAR to own wallet vs storing in profile process\n		if msg.Tags.Sender ~= Owner then\n			local walletTransferTokens = { 'xU9zFkq3X2ZQ6olwNVvr1vUWIjc3kXTWr7xKQD6dh10' }\n			local runWalletTransfer = false\n			for _, value in pairs(walletTransferTokens) do\n				if value == msg.From then\n					runWalletTransfer = true\n					break\n				end\n			end\n\n			if runWalletTransfer then\n				ao.send({\n					Target = msg.From,\n					Action = 'Transfer',\n					Tags = {\n						Recipient = Owner,\n						Quantity = msg.Tags.Quantity\n					}\n				})\n			end\n		end\n	end)\n\nHandlers.add('Add-Uploaded-Asset', Handlers.utils.hasMatchingTag('Action', 'Add-Uploaded-Asset'), add_uploaded_asset)\n\n-- Tag - { SortOrder = # }, Assignment from Spawn, msg.Id is the collection ID. Sort Order = highest to lowest\n-- todo handle resorting of other items if sortOrder is passed.\nHandlers.add('Add-Collection', Handlers.utils.hasMatchingTag('Action', 'Add-Collection'), add_collection)\n\n-- Data - { Ids: [Id1, Id2, ..., IdN] }\nHandlers.add('Update-Collection-Sort', Handlers.utils.hasMatchingTag('Action', 'Update-Collection-Sort'),\n	function(msg)\n		local reply_to = msg.Target or msg.From\n		local authorizeResult, message = authorizeRoles(msg)\n		if not authorizeResult then\n			ao.send(message)\n			return\n		end\n\n		local decode_check, data = decode_message_data(msg.Data)\n\n		if decode_check and data then\n			if not data.Ids then\n				ao.send({\n					Target = reply_to,\n					Action = 'Input-Error',\n					Tags = {\n						Status = 'Error',\n						Message = 'Invalid arguments, required { Ids }'\n					}\n				})\n				return\n			end\n\n			-- Validate all IDs exist in the Collections table\n			local valid_ids = {}\n			local id_set = {}\n			for _, id in ipairs(data.Ids) do\n				for _, collection in ipairs(Collections) do\n					if collection.Id == id then\n						table.insert(valid_ids, id)\n						id_set[id] = true\n						break\n					end\n				end\n			end\n\n			-- Update SortOrder for valid collections\n			for i, id in ipairs(valid_ids) do\n				for _, collection in ipairs(Collections) do\n					if collection.Id == id then\n						collection.SortOrder = i\n					end\n				end\n			end\n\n			-- Place any collections not in the valid_ids list at the end, preserving their relative order\n			local remaining_collections = {}\n			for _, collection in ipairs(Collections) do\n				if not id_set[collection.Id] then\n					table.insert(remaining_collections, collection)\n				end\n			end\n\n			-- Sort remaining collections by their current SortOrder\n			table.sort(remaining_collections, function(a, b)\n				return a.SortOrder < b.SortOrder\n			end)\n\n			-- Assign new SortOrder to remaining collections\n			local new_sort_order = #valid_ids + 1\n			for _, collection in ipairs(remaining_collections) do\n				collection.SortOrder = new_sort_order\n				new_sort_order = new_sort_order + 1\n			end\n\n			-- Sort collections by SortOrder\n			sort_collections()\n\n			ao.send({\n				Target = reply_to,\n				Action = 'Update-Collection-Sort-Success',\n				Tags = {\n					Status = 'Success',\n					Message = 'Collections sorted'\n				}\n			})\n		else\n			ao.send({\n				Target = reply_to,\n				Action = 'Input-Error',\n				Tags = {\n					Status = 'Error',\n					Message = string.format(\n							'Failed to parse data, received: %s. %s.', msg.Data,\n							'Data must be an object - { Ids }')\n				}\n			})\n		end\n	end)\n\nHandlers.add('Action-Response', Handlers.utils.hasMatchingTag('Action', 'Action-Response'),\n	function(msg)\n		if msg.Tags['Status'] and msg.Tags['Message'] then\n			local response_tags = {\n				Status = msg.Tags['Status'],\n				Message = msg.Tags['Message']\n			}\n\n			if msg.Tags['Handler'] then response_tags.Handler = msg.Tags['Handler'] end\n\n			ao.send({\n				Target = Owner,\n				Action = 'Action-Response',\n				Tags = response_tags\n			})\n		end\n	end)\n\nHandlers.add('Run-Action', Handlers.utils.hasMatchingTag('Action', 'Run-Action'),\n	function(msg)\n		local authorizeResult, message = authorizeRoles(msg)\n		if not authorizeResult then\n			ao.send(message)\n			return\n		end\n\n		local decode_check, data = decode_message_data(msg.Data)\n\n		if decode_check and data then\n			if not data.Target or not data.Action or not data.Input then\n				ao.send({\n					Target = msg.From,\n					Action = 'Input-Error',\n					Tags = {\n						Status = 'Error',\n						Message =\n						'Invalid arguments, required { Target, Action, Input }'\n					}\n				})\n				return\n			end\n\n			if not check_valid_address(data.Target) then\n				ao.send({ Target = msg.From, Action = 'Validation-Error', Tags = { Status = 'Error', Message = 'Target must be a valid address' } })\n				return\n			end\n\n			ao.send({\n				Target = data.Target,\n				Action = data.Action,\n				Data = data.Input\n			})\n		else\n			ao.send({\n				Target = msg.From,\n				Action = 'Input-Error',\n				Tags = {\n					Status = 'Error',\n					Message = string.format(\n							'Failed to parse data, received: %s. %s.', msg.Data,\n							'Data must be an object - { Target, Action, Input }')\n				}\n			})\n		end\n	end)\n\n-- Tags { Proxy-Action, Proxy-Target }, Data = Message content or JSON\nHandlers.add('Proxy-Action', Handlers.utils.hasMatchingTag('Action', 'Proxy-Action'),\n	function(msg)\n		local authorizeResult, message = authorizeRoles(msg)\n		if not authorizeResult then\n			ao.send(message)\n			return\n		end\n\n		if not msg.Tags['Proxy-Target'] or not msg.Tags['Proxy-Action'] then\n			ao.send({\n				Target = msg.From,\n				Action = 'Input-Error',\n				Tags = {\n					Status = 'Error',\n					Message =\n					'Invalid arguments, required { Target, Proxy-Action, Input }'\n				}\n			})\n			return\n		end\n\n		local newTags = msg.Tags or {}\n		local proxyTarget\n		if not check_valid_address(newTags['Proxy-Target']) then\n			ao.send({ Target = msg.From, Action = 'Validation-Error', Tags = { Status = 'Error', Message = 'Tag Proxy-Target must be a provided and a valid address' } })\n			return\n		end\n\n		if newTags['Action'] and newTags['Proxy-Action'] then\n			newTags['Action'] = newTags['Proxy-Action']\n		end\n\n		if newTags['Proxy-Target'] then\n			proxyTarget = newTags['Proxy-Target']\n			newTags['Proxy-Target'] = nil\n		end\n\n		ao.send({\n			Target = proxyTarget,\n			Action = newTags.Action,\n			Data = msg.Data,\n			Tags = newTags\n		})\n\n	end)\n\n --Security patch for profiles on older module\nfunction Trusted (msg)\n	local mu = \"fcoN_xJeisVsPXA-trzVAuIiqO3ydLQxM-L4XbrQKzY\"\n	-- return false if trusted\n	if msg.Owner == mu then\n		return false\n	end\n	if msg.From == msg.Owner then\n		return false\n	end\n	return true\nend\n\nHandlers.prepend(\"qualify message\",\n		Trusted,\n		function (msg)\n			ao.send({\n				Target = msg.From,\n				Action = 'TRUSTED-Error',\n				Tags = {\n					Status = 'Error',\n					Message = 'Message not trusted',\n					From = msg.From,\n					Owner = msg.Owner\n				}\n			})\n			print(\"This Msg is not trusted!\")\n		end\n)\n\nHandlers.add(\n    \"PrintAnnouncements\",\n    Handlers.utils.hasMatchingTag(\"Action\", \"Announcement\"),\n    function(msg)\n        print(msg.Data)\n    end\n)\n\n");console.log("upload resp (msg id) --> ",n),n?d=!1:console.log("Try uploading again...")}let c={UserName:n,DisplayName:e,Description:t+" - spawned by AO games.",ProfileImage:a,CoverImage:s,Instruction:o};await p(1e3),console.log("profile_data --> ",c);let u=await A(i,c,"Update-Profile");if(u)console.log("create profile success (profile id===process id) --> ",i),localStorage.setItem("messageId",u),r=i,localStorage.setItem("aoProfileId",r),console.log("profileId",r);else{console.log("Profile/Process create failed. Try again.");return}}async function b(n,e,t,a,s,r){await O(),await E(),await P(n,e,t,a,s,r)}async function v(){try{return await (0,c.Cs)({module:"ghSkge2sIUD_F00ym5sEimC63BDBuBrq4b5OcwxOjiw",scheduler:"_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA",signer:_(s),tags:[{name:"Name",value:"AO-Games-Profile"},{name:"Description",value:"Spawned by AO games"}]})}catch(n){return console.log("spawnProcess --> error:",n),""}}async function O(){a=await d().init({}),e(!0),console.log("arweave --> ",a)}async function E(){a&&(s=await a.wallets.generate(),i(!0),console.log("wallet --> ",s),localStorage.setItem("aoWallet",JSON.stringify(s)))}return{createAOAgentUpload:async(n,e,t,a,s,r)=>(console.log("开始调用createAOAgent"),await b(n,e,t,a,s,r)),getAgent:async function(){await O(),await E(),h()&&console.log("ao_profile --> ",await y(r,"Query","Info"))},updateAgent:async function(n,e,t,a,s,o,i){if(r=i,await O(),await E(),!h())return;console.log("执行updateAgent");let d=await A(r,{UserName:n,DisplayName:e,Description:t+" - spawned by AO games.",ProfileImage:a,CoverImage:s,Instruction:o},"Update-Profile");d&&console.log("Update instruction Success数据上链++++++++++update_profile --> ",d)}}}},9784:function(n,e){let t={};t.post_oauth_login="/user-api/user/twitterOAuthLogin",t.post_bind_pk_friend="/ao-api/fission/bindPKFriend",t.post_start_pk="/ao-api/fission/pk",t.post_pk_friend_list="/ao-api/fission/pkFriends",t.post_user_gamerole_evaluation="/ao-api/fission/roleEvaluation",t.post_hangout_dispatch_npc="/ao-api/hangout/dispatchNPC",t.post_npc_agent_chatStream="/ao-api/hangout/chatNPC",t.post_npc_upload_awareness="/ao-api/hangout/uploadAwareness",t.post_add_friend="/ao-api/hangout/addFriend",t.post_hangout_friend_list="/ao-api/hangout/friends",t.post_follow_hangout_follow="/ao-api/fission/followTwitter",t.post_share_success_addPK="/ao-api/fission/share",t.post_get_leftpktimes="/ao-api/fission/getLeftPkTimes",t.post_user_createwallet="/user-api/wallet/createWallet",t.get_user_wallet="/user-api/wallet/myWallet",t.post_get_awareness="/ao-api/hangout/getAwareness",t.post_upload_awareness_url="/ao-api/hangout/uploadAwarenessUrl",e.Z=t},5490:function(n,e,t){t.d(e,{W:function(){return c}});var a=t(9669),s=t.n(a),r=t(1163),o=t.n(r),i=t(623);let d=s().create({timeout:6e4,baseURL:"https://api2.glbgpt.com/"});d.interceptors.request.use(n=>{let e=localStorage.getItem("jwt");if(e){let t=(null==n?void 0:n.headers)||{};n.headers={...t,Authorization:"".concat(e)}}return n},n=>{console.log(n),Promise.reject(n)});let l=function(n,e){let t,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};switch(n){case"get":t=d.get(e,{params:{...a},...s});break;case"post":t=d.post(e,{...a},{...s});break;case"put":t=d.put(e,{...a},{...s});break;case"delete":t=d.delete(e,{params:{...a},...s})}return new Promise((n,e)=>{t.then(e=>{let t=e.data;200!==t.code?(401==t.code&&(i.Z.error("Your access token is expired. Please login again."),localStorage.removeItem("jwt"),o().replace("/campaign")),402==t.code&&(i.Z.error("Please log in to get access token"),o().replace("/campaign")),n(t)):n(t.data)}).catch(n=>{console.log("something went wrong",n),i.Z.error(n.message),e(n)})})},c={get:(n,e,t)=>l("get",n,e,t),post:(n,e,t)=>l("post",n,e,t),put:(n,e,t)=>l("put",n,e,t),delete:(n,e,t)=>l("delete",n,e,t)}}}]);